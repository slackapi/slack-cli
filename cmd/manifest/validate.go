// Copyright 2022-2025 Salesforce, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package manifest

import (
	"context"
	"slices"
	"strings"

	"github.com/opentracing/opentracing-go"
	"github.com/slackapi/slack-cli/internal/app"
	"github.com/slackapi/slack-cli/internal/cmdutil"
	"github.com/slackapi/slack-cli/internal/iostreams"
	"github.com/slackapi/slack-cli/internal/logger"
	"github.com/slackapi/slack-cli/internal/pkg/manifest"
	"github.com/slackapi/slack-cli/internal/prompts"
	"github.com/slackapi/slack-cli/internal/shared"
	"github.com/slackapi/slack-cli/internal/shared/types"
	"github.com/slackapi/slack-cli/internal/slackerror"
	"github.com/slackapi/slack-cli/internal/slacktrace"
	"github.com/slackapi/slack-cli/internal/style"
	"github.com/spf13/cobra"
)

// TODO - Find best practice, such as using an Interface and Struct to create a client
var manifestValidateFunc = manifest.ManifestValidate

func NewValidateCommand(clients *shared.ClientFactory) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "validate",
		Short: "Validate the app manifest generated by a project",
		Long:  "Validate the app manifest generated from a valid project directory",
		Example: style.ExampleCommandsf([]style.ExampleCommand{
			{Command: "manifest validate", Meaning: "Validate the app manifest generated by a project"},
		}),
		Aliases: []string{"verify", "check"},
		Args:    cobra.NoArgs,
		FParseErrWhitelist: cobra.FParseErrWhitelist{
			UnknownFlags: true,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			// Verify command is run in a project directory
			return cmdutil.IsValidProjectDirectory(clients)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx := cmd.Context()
			var span, _ = opentracing.StartSpanFromContext(ctx, "cmd.manifest.validate")
			defer span.Finish()

			// Get the app selection and accompanying auth of an installed app or gather
			// some other authentication token
			var token string
			selection, err := appSelectPromptFunc(ctx, clients, prompts.ShowInstalledAppsOnly)
			if err != nil {
				if slackerror.ToSlackError(err).Code != slackerror.ErrInstallationRequired {
					return err
				}
				auth, err := gatherAuthenticationToken(ctx, clients)
				if err != nil {
					return err
				}
				token = auth.Token
			} else {
				token = selection.Auth.Token
			}

			clients.Config.ManifestEnv = app.SetManifestEnvTeamVars(clients.Config.ManifestEnv, selection.App.TeamDomain, selection.App.IsDev)

			logger := newValidateLogger(clients, cmd)
			log, warn, err := manifestValidateFunc(ctx, clients, logger, selection.App, token)
			if err != nil {
				return err
			}
			if warn != nil {
				clients.IO.PrintWarning(ctx, warn.Warning(clients.Config.DebugEnabled, "The following warnings were raised during manifest validation"))
				return nil
			}
			if log != nil {
				var isValid = log.DataToBool("isValid")
				if isValid {
					cmd.Printf(
						"\n%s: %s\n",
						style.Bold("App Manifest Validation Result"),
						style.Styler().Green("Valid"),
					)
					clients.IO.PrintTrace(ctx, slacktrace.ManifestValidateSuccess)
				} else {
					cmd.Printf(
						"\n%s: %s\n",
						style.Bold("App Manifest Validation Result"),
						style.Styler().Red("InValid"),
					)
				}
			}
			return nil
		},
	}

	return cmd
}

// newValidateLogger creates a logger instance to receive event notifications
func newValidateLogger(clients *shared.ClientFactory, cmd *cobra.Command) *logger.Logger {
	return logger.New(
		// OnEvent
		func(event *logger.LogEvent) {
			switch event.Name {
			default:
				// Ignore the event
			}
		},
	)
}

// gatherAuthenticationToken returns some user token and configures authentication
// internals for API use
func gatherAuthenticationToken(ctx context.Context, clients *shared.ClientFactory) (auth types.SlackAuth, err error) {
	defer func() {
		if err == nil {
			clients.Auth().SetSelectedAuth(ctx, auth, clients.Config, clients.Os)
		}
	}()
	auths, err := clients.Auth().Auths(ctx)
	if err != nil {
		return types.SlackAuth{}, err
	}
	if len(auths) == 0 {
		return types.SlackAuth{}, slackerror.New(slackerror.ErrNotAuthed)
	}
	if len(auths) == 1 {
		return auths[0], nil
	}

	// Multiple authentications are available so a selection must be made
	type AuthLabel struct {
		auth  types.SlackAuth
		label string
	}
	var authLabels []AuthLabel
	for _, a := range auths {
		authLabels = append(authLabels, AuthLabel{auth: a, label: a.TeamDomain})
	}
	slices.SortFunc(authLabels, func(a, b AuthLabel) int {
		if a.auth.TeamDomain != b.auth.TeamDomain {
			return strings.Compare(a.auth.TeamDomain, b.auth.TeamDomain)
		}
		return strings.Compare(a.auth.TeamID, b.auth.TeamID)
	})
	var teamLabels []string
	for _, auth := range authLabels {
		teamLabels = append(teamLabels, auth.label)
	}
	selection, err := clients.IO.SelectPrompt(ctx, prompts.SelectTeamPrompt, teamLabels, iostreams.SelectPromptConfig{
		Flag:     clients.Config.Flags.Lookup("team"),
		Required: true,
	})
	switch {
	case err != nil:
		return types.SlackAuth{}, err
	case selection.Flag:
		for _, auth := range auths {
			if auth.TeamID == selection.Option || auth.TeamDomain == selection.Option {
				return auth, nil
			}
		}
		return types.SlackAuth{}, slackerror.New(slackerror.ErrInvalidAuth)
	case selection.Prompt:
		return auths[selection.Index], nil
	default:
		return types.SlackAuth{}, slackerror.New(slackerror.ErrInvalidAuth)
	}
}
